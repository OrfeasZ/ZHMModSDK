#include "CodeGen.h"
#include "Logging.h"

#include <Glacier/ZString.h>
#include <Glacier/ZTypeRegistry.h>
#include <Glacier/Reflection.h>

#include "Globals.h"

#include <sstream>
#include <iostream>
#include <fstream>

void CodeGen::OnEngineInitialized()
{
	Generate();
}

void CodeGen::Generate()
{
	auto s_Registry = *Globals::TypeRegistry;

	m_PropertyNames.clear();

	Logger::Info("Generating code for types...");

	// Open our output files.
	m_ClassesFile.open("classes.txt", std::ofstream::out);
	m_EnumsFile.open("enums.txt", std::ofstream::out);
	
	m_SDKEnumsHeader.open("Enums.h", std::ofstream::out);

	m_ReflectiveClassesHeaderFile.open("ZHMGen.h", std::ofstream::out);
	m_ReflectiveClassesSourceFile.open("ZHMGen.cpp", std::ofstream::out);

	m_PropertyNamesHeaderFile.open("ZHMProperties.h", std::ofstream::out);
	m_PropertyNamesSourceFile.open("ZHMProperties.cpp", std::ofstream::out);

	m_EnumsHeaderFile.open("ZHMEnums.h", std::ofstream::out);
	m_EnumsSourceFile.open("ZHMEnums.cpp", std::ofstream::out);

	m_SDKEnumsHeader << "/*" << std::endl;
	m_SDKEnumsHeader << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_SDKEnumsHeader << " *" << std::endl;
	m_SDKEnumsHeader << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_SDKEnumsHeader << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_SDKEnumsHeader << " */" << std::endl;
	m_SDKEnumsHeader << std::endl;
	m_SDKEnumsHeader << "#pragma once" << std::endl;
	m_SDKEnumsHeader << std::endl;
	
	m_ReflectiveClassesHeaderFile << "/*" << std::endl;
	m_ReflectiveClassesHeaderFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_ReflectiveClassesHeaderFile << " *" << std::endl;
	m_ReflectiveClassesHeaderFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_ReflectiveClassesHeaderFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_ReflectiveClassesHeaderFile << " */" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;
	m_ReflectiveClassesHeaderFile << "#pragma once" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;
	m_ReflectiveClassesHeaderFile << "#include <ZHM/ZHMPrimitives.h>" << std::endl;
	m_ReflectiveClassesHeaderFile << "#include <ZHM/ZHMTypeInfo.h>" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;

	m_ReflectiveClassesHeaderFile << "class ZHMTypeInfo;" << std::endl;
	m_ReflectiveClassesHeaderFile << std::endl;

	m_ReflectiveClassesSourceFile << "/*" << std::endl;
	m_ReflectiveClassesSourceFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_ReflectiveClassesSourceFile << " *" << std::endl;
	m_ReflectiveClassesSourceFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_ReflectiveClassesSourceFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_ReflectiveClassesSourceFile << " */" << std::endl;
	m_ReflectiveClassesSourceFile << std::endl;
	m_ReflectiveClassesSourceFile << "#include \"ZHMGen.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << "#include \"ZHMProperties.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << "#include \"ZHMEnums.h\"" << std::endl;
	m_ReflectiveClassesSourceFile << std::endl;

	for (auto& s_TypeDef : s_Registry->m_types)
	{
		auto s_Type = s_TypeDef.second;

		if (s_Type->typeInfo()->isEnum())
		{
			GenerateEnum(s_Type);
			GenerateReflectiveEnum(s_Type);
		}
	}

	for (auto& s_TypeDef : s_Registry->m_types)
	{
		auto s_Type = s_TypeDef.second;

		if (s_Type->typeInfo()->isClass())
		{
			GenerateClass(s_Type);

			if (!s_Type->typeInfo()->isEntity())
				GenerateReflectiveClass(s_Type);
		}
	}

	GenerateReflectiveClasses();
	GeneratePropertyNamesFiles();
	GenerateEnumsFiles();

	m_ClassesFile.close();
	m_EnumsFile.close();
	
	m_SDKEnumsHeader.close();

	m_ReflectiveClassesHeaderFile.close();
	m_ReflectiveClassesSourceFile.close();

	m_PropertyNamesHeaderFile.close();
	m_PropertyNamesSourceFile.close();

	Logger::Info("Finished generating code.");
}

void CodeGen::GenerateClass(STypeID* p_Type)
{
	auto s_Type = reinterpret_cast<IClassType*>(p_Type->typeInfo());

	std::ostringstream s_Stream;

	s_Stream << "// 0x" << std::hex << std::uppercase << p_Type << " (Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << ")" << std::dec << std::endl;
	s_Stream << "class " << s_Type->m_pTypeName;

	if (s_Type->m_nBaseClassCount > 0 || s_Type->m_nInterfaceCount > 0)
		s_Stream << " :";

	s_Stream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nInterfaceCount; ++i)
	{
		if (!s_Type->m_pInterfaces[i].m_pType->typeInfo())
		{
			s_Stream << "// Unknown interface at offset 0x" << std::hex << s_Type->m_pInterfaces[i].m_nOffset << " " << std::dec << std::endl;
			continue;
		}

		s_Stream << "\tpublic " << s_Type->m_pInterfaces[i].m_pType->typeInfo()->m_pTypeName << ", // Offset 0x" << std::hex << s_Type->m_pInterfaces[i].m_nOffset << " " << std::dec << std::endl;
	}

	for (uint16_t i = 0; i < s_Type->m_nBaseClassCount; ++i)
	{
		if (!s_Type->m_pBaseClasses[i].m_pType->typeInfo())
		{
			s_Stream << "// Unknown base class at offset 0x" << std::hex << s_Type->m_pBaseClasses[i].m_nOffset << " " << std::dec << std::endl;
			continue;
		}

		s_Stream << "\tpublic " << s_Type->m_pBaseClasses[i].m_pType->typeInfo()->m_pTypeName << ", // Offset 0x" << std::hex << s_Type->m_pBaseClasses[i].m_nOffset << " " << std::dec << std::endl;
	}

	if (s_Type->m_nBaseClassCount > 0 || s_Type->m_nInterfaceCount > 0)
	{
		s_Stream.seekp(-2, s_Stream.cur);
		s_Stream << std::endl;
		s_Stream.flush();
	}

	s_Stream << "{" << std::endl;
	s_Stream << "public:" << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];

		m_PropertyNames[s_Prop.m_nPropertyID] = s_Prop.m_pName;

		if (!s_Prop.m_pType->typeInfo())
		{
			uint64_t s_PropSize = 8;

			if (i < s_Type->m_nPropertyCount - 1)
				s_PropSize = s_Type->m_pProperties[i + 1].m_nOffset - s_Prop.m_nOffset;
			else
				s_PropSize = static_cast<uint64_t>(s_Type->m_nTypeSize) - s_Prop.m_nOffset;

			s_Stream << "\tchar " << s_Prop.m_pName << "[0x" << std::hex << std::uppercase << s_PropSize << std::dec << "];";

		}
		else
		{
			s_Stream << "\t" << s_Prop.m_pType->typeInfo()->m_pTypeName << " " << s_Prop.m_pName << ";";
		}

		s_Stream << " // 0x" << std::hex << std::uppercase << s_Prop.m_nOffset << std::dec << std::endl;
	}

	for (uint16_t i = 0; i < s_Type->m_nInputCount; ++i)
	{
		auto s_Input = s_Type->m_pInputs[i];

		s_Stream << "\tchar void" << s_Input.m_pName << "();" << std::endl;
	}

	s_Stream << "};" << std::endl << std::endl;
	s_Stream.flush();

	// Write to file.
	m_ClassesFile << s_Stream.str();
}

std::vector<std::string> SplitString(const std::string& p_String, char p_Delimiter)
{
	std::vector<std::string> s_Parts;

	std::stringstream s_Stream(p_String);
	std::string s_Part;

	while (std::getline(s_Stream, s_Part, p_Delimiter))
		s_Parts.push_back(s_Part);

	return s_Parts;
}

std::string NormalizeName(STypeID* p_Type)
{
	std::string s_TypeName = p_Type->typeInfo()->m_pTypeName;

	if (s_TypeName == "TArray")
		return s_TypeName;

	if (p_Type->typeInfo()->isFixedArray())
	{
		auto s_ElementType = reinterpret_cast<IArrayType*>(p_Type->typeInfo())->m_pArrayElementType;
		return "TFixedArray<" + NormalizeName(s_ElementType) + ", " + std::to_string(reinterpret_cast<IArrayType*>(p_Type->typeInfo())->fixedArraySize()) + ">";
	}

	if (p_Type->typeInfo()->isArray())
	{
		auto s_ElementType = reinterpret_cast<IArrayType*>(p_Type->typeInfo())->m_pArrayElementType;
		return "TArray<" + NormalizeName(s_ElementType) + ">";
	}

	auto s_DotIndex = s_TypeName.find_first_of('.');

	while (s_DotIndex != std::string::npos)
	{
		s_TypeName[s_DotIndex] = '_';
		s_DotIndex = s_TypeName.find_first_of('.');
	}

	return s_TypeName;
}

void CodeGen::GenerateEnum(STypeID* p_Type)
{
	auto s_Type = reinterpret_cast<IEnumType*>(p_Type->typeInfo());

	std::unordered_map<int, std::string> s_Enum;

	//if (std::string(s_Type->m_pTypeName).find_first_of('.') != std::string::npos)
	//	return;

	{
		std::ostringstream s_Stream;

		s_Stream << "// 0x" << std::hex << std::uppercase << p_Type << " (Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << ")" << std::dec << std::endl;
		s_Stream << "enum class " << s_Type->m_pTypeName << std::endl;
		s_Stream << "{" << std::endl;

		for (auto it = s_Type->m_entries.begin(); it != s_Type->m_entries.end(); ++it)
		{
			s_Enum[it->m_nValue] = it->m_pName;
			s_Stream << "\t" << it->m_pName << " = " << std::dec << it->m_nValue << "," << std::endl;
		}

		s_Stream << "};" << std::endl << std::endl;
		s_Stream.flush();

		// Write to file.
		m_EnumsFile << s_Stream.str();
	}
	
	{
		std::ostringstream s_Stream;

		s_Stream << "enum class " << NormalizeName(p_Type) << std::endl;
		s_Stream << "{" << std::endl;

		for (auto it = s_Type->m_entries.begin(); it != s_Type->m_entries.end(); ++it)
		{
			s_Enum[it->m_nValue] = it->m_pName;
			s_Stream << "\t" << it->m_pName << " = " << std::dec << it->m_nValue << "," << std::endl;
		}

		s_Stream << "};" << std::endl << std::endl;
		s_Stream.flush();

		// Write to file.
		m_SDKEnumsHeader << s_Stream.str();
	}

	m_Enums[s_Type->m_pTypeName] = s_Enum;
}

void GenerateArrayJsonWriter(STypeID* p_ElementType, std::ostream& p_Stream, const std::string& p_ValueName, int p_Depth = 0, const std::string& p_Indentation = "")
{
	p_Stream << p_Indentation << "\tp_Stream << \"[\";" << std::endl;

	p_Stream << p_Indentation << "\tfor (size_t i = 0; i < " << p_ValueName << ".size(); ++i)" << std::endl;
	p_Stream << p_Indentation << "\t{" << std::endl;
	p_Stream << p_Indentation << "\t\tauto& s_Item" << p_Depth << " = " << p_ValueName << "[i];" << std::endl;

	auto s_ArrayType = reinterpret_cast<IArrayType*>(p_ElementType->typeInfo());
	auto s_ArrayTypeName = std::string(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);

	p_Stream << p_Indentation << "\t\tp_Stream << \"{\" << JsonStr(\"$type\") << \":\" << JsonStr(\"" << s_ArrayTypeName << "\") << \",\" << JsonStr(\"$val\") << \":\";" << std::endl;

	if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
	{
		if (s_ArrayTypeName == "uint8" || s_ArrayTypeName == "int8")
			p_Stream << p_Indentation << "\t\tp_Stream << static_cast<int>(s_Item" << p_Depth << ");" << std::endl;
		else
			p_Stream << p_Indentation << "\t\tp_Stream << s_Item" << p_Depth << ";" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
	{
		p_Stream << p_Indentation << "\t\tp_Stream << \"{\" << JsonStr(\"$enumVal\") << \":\" << static_cast<int>(s_Item" << p_Depth << ") << \",\" << JsonStr(\"$enumValName\") << \":\" << JsonStr(ZHMEnums::GetEnumValueName(\"" << s_ArrayTypeName << "\", static_cast<int>(s_Item" << p_Depth << "))) << \"}\";" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
	{
		p_Stream << p_Indentation << "\t\tp_Stream << JsonStr(s_Item" << p_Depth << ");" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
	{
		GenerateArrayJsonWriter(s_ArrayType->m_pArrayElementType, p_Stream, "s_Item" + std::to_string(p_Depth), p_Depth + 1, p_Indentation + "\t");
	}
	else
	{
		p_Stream << p_Indentation << "\t\t" << s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName << "::WriteJson(&s_Item" << p_Depth << ", p_Stream);" << std::endl;
	}

	p_Stream << p_Indentation << "\t\tp_Stream << \"}\";" << std::endl;
	p_Stream << std::endl;
	p_Stream << p_Indentation << "\t\tif (i < " << p_ValueName << ".size() - 1)" << std::endl;
	p_Stream << p_Indentation << "\t\t\tp_Stream << \",\";" << std::endl;

	p_Stream << p_Indentation << "\t}" << std::endl;

	p_Stream << p_Indentation << "\tp_Stream << \"]\";" << std::endl;
}

void GenerateArraySimpleJsonWriter(STypeID* p_ElementType, std::ostream& p_Stream, const std::string& p_ValueName, int p_Depth = 0, const std::string& p_Indentation = "")
{
	p_Stream << p_Indentation << "\tp_Stream << \"[\";" << std::endl;
	p_Stream << p_Indentation << "\tfor (size_t i = 0; i < " << p_ValueName << ".size(); ++i)" << std::endl;
	p_Stream << p_Indentation << "\t{" << std::endl;
	p_Stream << p_Indentation << "\t\tauto& s_Item" << p_Depth << " = " << p_ValueName << "[i];" << std::endl;

	auto s_ArrayType = reinterpret_cast<IArrayType*>(p_ElementType->typeInfo());
	auto s_ArrayTypeName = std::string(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);

	if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
	{
		if (s_ArrayTypeName == "uint8" || s_ArrayTypeName == "int8")
			p_Stream << p_Indentation << "\t\tp_Stream << static_cast<int>(s_Item" << p_Depth << ");" << std::endl;
		else
			p_Stream << p_Indentation << "\t\tp_Stream << s_Item" << p_Depth << ";" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
	{
		p_Stream << p_Indentation << "\t\tp_Stream << JsonStr(ZHMEnums::GetEnumValueName(\"" << s_ArrayTypeName << "\", static_cast<int>(s_Item" << p_Depth << ")));" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
	{
		p_Stream << p_Indentation << "\t\tp_Stream << JsonStr(s_Item" << p_Depth << ");" << std::endl;
	}
	else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
	{
		GenerateArraySimpleJsonWriter(s_ArrayType->m_pArrayElementType, p_Stream, "s_Item" + std::to_string(p_Depth), p_Depth + 1, p_Indentation + "\t");
	}
	else
	{
		p_Stream << p_Indentation << "\t\t" << s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName << "::WriteSimpleJson(&s_Item" << p_Depth << ", p_Stream);" << std::endl;
	}

	p_Stream << std::endl;
	p_Stream << p_Indentation << "\t\tif (i < " << p_ValueName << ".size() - 1)" << std::endl;
	p_Stream << p_Indentation << "\t\t\tp_Stream << \",\";" << std::endl;

	p_Stream << p_Indentation << "\t}" << std::endl;
	p_Stream << std::endl;
	p_Stream << p_Indentation << "\tp_Stream << \"]\";" << std::endl;
}
void GenerateArraySimpleJsonReader(STypeID* p_ElementType, std::ostream& p_Stream, const std::string& p_ValueName, const std::string& p_ArrayName, int p_Depth = 0, const std::string& p_Indentation = "")
{
	auto s_ArrayType = reinterpret_cast<IArrayType*>(p_ElementType->typeInfo());
	auto s_ArrayTypeName = std::string(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);
	auto s_NormalizedArrayType = NormalizeName(s_ArrayType->m_pArrayElementType);

	if (s_ArrayType->isFixedArray())
	{
		p_Stream << p_Indentation << "\tsize_t s_Index" << p_Depth << " = 0;" << std::endl;
		p_Stream << p_Indentation << "\tfor (simdjson::ondemand::value s_Item" << p_Depth << " : " << p_ArrayName << ")" << std::endl;
		p_Stream << p_Indentation << "\t{" << std::endl;

		if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
		{
			if (s_ArrayTypeName == "int8" || s_ArrayTypeName == "uint8" || s_ArrayTypeName == "int16" || s_ArrayTypeName == "uint16" || s_ArrayTypeName == "int32" || s_ArrayTypeName == "uint32")
				p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = static_cast<" << s_ArrayTypeName << ">(int64_t(s_Item" << p_Depth << "));" << std::endl;
			else if (s_ArrayTypeName == "float32")
				p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = static_cast<" << s_ArrayTypeName << ">(double(s_Item" << p_Depth << "));" << std::endl;
			else
				p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = " << s_ArrayTypeName << "(s_Item" << p_Depth << ");" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = static_cast<" << s_NormalizedArrayType << ">(ZHMEnums::GetEnumValueByName(\"" << s_ArrayTypeName << "\", std::string_view(s_Item" << p_Depth << ")));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = std::string_view(s_Item" << p_Depth << ");" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << " s_ArrayItem" << p_Depth << ";" << std::endl;

			GenerateArraySimpleJsonReader(s_ArrayType->m_pArrayElementType, p_Stream, "s_ArrayItem" + std::to_string(p_Depth), "s_Item" + std::to_string(p_Depth), p_Depth + 1, p_Indentation + "\t");

			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = s_ArrayItem" << p_Depth << ";" << std::endl;
		}
		else
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << " s_ArrayItem" << p_Depth << ";" << std::endl;
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << "::FromSimpleJson(s_Item" << p_Depth << ", &s_ArrayItem" << p_Depth << ");" << std::endl;
			p_Stream << p_Indentation << "\t\t" << p_ValueName << "[s_Index" << p_Depth << "] = s_ArrayItem" << p_Depth << ";" << std::endl;
		}

		p_Stream << p_Indentation << "\t\t++s_Index" << p_Depth << ";" << std::endl;

		p_Stream << p_Indentation << "\t}" << std::endl;
	}
	else
	{
		p_Stream << p_Indentation << "\tfor (simdjson::ondemand::value s_Item" << p_Depth << " : " << p_ArrayName << ")" << std::endl;
		p_Stream << p_Indentation << "\t{" << std::endl;

		if (s_ArrayType->m_pArrayElementType->typeInfo()->isPrimitive())
		{
			if (s_ArrayTypeName == "int8" || s_ArrayTypeName == "uint8" || s_ArrayTypeName == "int16" || s_ArrayTypeName == "uint16" || s_ArrayTypeName == "int32" || s_ArrayTypeName == "uint32")
				p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(static_cast<" << s_ArrayTypeName << ">(int64_t(s_Item" << p_Depth << ")));" << std::endl;
			else if (s_ArrayTypeName == "float32")
				p_Stream << "\t\t" << p_ValueName << ".push_back(static_cast<" << s_ArrayTypeName << ">(double(s_Item" << p_Depth << ")));" << std::endl;
			else
				p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(" << s_ArrayTypeName << "(s_Item" << p_Depth << "));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isEnum())
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(static_cast<" << s_NormalizedArrayType << ">(ZHMEnums::GetEnumValueByName(\"" << s_ArrayTypeName << "\", std::string_view(s_Item" << p_Depth << "))));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(std::string_view(s_Item" << p_Depth << "));" << std::endl;
		}
		else if (s_ArrayType->m_pArrayElementType->typeInfo()->isArray() || s_ArrayType->m_pArrayElementType->typeInfo()->isFixedArray())
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << " s_ArrayItem" << p_Depth << ";" << std::endl;

			GenerateArraySimpleJsonReader(s_ArrayType->m_pArrayElementType, p_Stream, "s_ArrayItem" + std::to_string(p_Depth), "s_Item" + std::to_string(p_Depth), p_Depth + 1, p_Indentation + "\t");

			p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(s_ArrayItem" << p_Depth << ");" << std::endl;
		}
		else
		{
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << " s_ArrayItem" << p_Depth << ";" << std::endl;
			p_Stream << p_Indentation << "\t\t" << s_NormalizedArrayType << "::FromSimpleJson(s_Item" << p_Depth << ", &s_ArrayItem" << p_Depth << ");" << std::endl;
			p_Stream << p_Indentation << "\t\t" << p_ValueName << ".push_back(s_ArrayItem" << p_Depth << ");" << std::endl;
		}

		p_Stream << p_Indentation << "\t}" << std::endl;
	}
}

void CodeGen::GenerateReflectiveClass(STypeID* p_Type)
{
	auto s_Type = reinterpret_cast<IClassType*>(p_Type->typeInfo());

	if (s_Type->m_nInterfaceCount > 0)
		return;

	// TODO: Maybe support inheritance in the future.
	if (s_Type->m_nBaseClassCount > 0)
		return;

	auto s_GenType = new GeneratedType();

	std::ostringstream s_HeaderStream;

	std::string s_Indent = "";
	bool s_IsNamespaced = false;

	std::string s_TypeName = s_Type->m_pTypeName;
	std::string s_NormalizedName = NormalizeName(p_Type);

	// We skip this since it uses map types that I don't feel like implementing and it doesn't
	// exist in game data anyway. Probably tool-only.
	if (s_TypeName == "SEntityPropertyDescriptor")
		return;

	/*if (s_LastDot != std::string::npos)
	{
		auto s_NamespaceParts = SplitString(s_TypeName.substr(0, s_LastDot), '.');

		s_TypeName = s_TypeName.substr(s_LastDot + 1);

		s_IsNamespaced = true;

		s_HeaderStream << "namespace ";

		for (auto i = 0; i < s_NamespaceParts.size(); ++i)
		{
			if (i > 0)
				s_HeaderStream << "::";

			s_HeaderStream << s_NamespaceParts[i];
		}

		s_HeaderStream << std::endl;
		s_HeaderStream << "{" << std::endl;

		s_Indent = "\t";
	}

	// TODO: Remove this once we support namespacing.
	if (s_IsNamespaced)
		return;*/

	if (s_TypeName.find_first_of('<') != std::string::npos)
		return;

	s_HeaderStream << s_Indent << "// 0x" << std::hex << std::uppercase << p_Type << " (Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << ")" << std::dec << std::endl;
	s_HeaderStream << s_Indent << "class alignas(" << s_Type->m_nTypeAlignment << ") " << s_NormalizedName;

	if (s_Type->m_nBaseClassCount > 0)
		s_HeaderStream << " :";

	s_HeaderStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nBaseClassCount; ++i)
	{
		if (!s_Type->m_pBaseClasses[i].m_pType->typeInfo())
		{
			printf("Unknown base class for %s.\n", s_TypeName.c_str());
			return;
		}

		// TODO: Remove this once we support namespacing.
		if (std::string(s_Type->m_pBaseClasses[i].m_pType->typeInfo()->m_pTypeName).find_first_of('.') != std::string::npos)
			return;

		s_GenType->Dependencies.insert(s_Type->m_pBaseClasses[i].m_pType->typeInfo()->m_pTypeName);

		s_HeaderStream << s_Indent << "\tpublic " << s_Type->m_pBaseClasses[i].m_pType->typeInfo()->m_pTypeName << "," << std::endl;
	}

	if (s_Type->m_nBaseClassCount > 0)
	{
		s_HeaderStream.seekp(-2, s_HeaderStream.cur);
		s_HeaderStream << std::endl;
		s_HeaderStream.flush();
	}

	s_HeaderStream << s_Indent << "{" << std::endl;
	s_HeaderStream << s_Indent << "public:" << std::endl;

	s_HeaderStream << s_Indent << "\tstatic ZHMTypeInfo TypeInfo;" << std::endl;
	s_HeaderStream << s_Indent << "\tstatic void WriteJson(void* p_Object, std::ostream& p_Stream);" << std::endl;
	s_HeaderStream << s_Indent << "\tstatic void WriteSimpleJson(void* p_Object, std::ostream& p_Stream);" << std::endl;
	s_HeaderStream << s_Indent << "\tstatic void FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target);" << std::endl;
	s_HeaderStream << s_Indent << "\tstatic void Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset);" << std::endl;
	s_HeaderStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];

		m_PropertyNames[s_Prop.m_nPropertyID] = s_Prop.m_pName;

		if (!s_Prop.m_pType->typeInfo())
		{
			printf("Could not get typeinfo for property in type %s.\n", s_TypeName.c_str());
			return;
		}
		else
		{
			// TODO: Remove this once we support namespacing.
			if (std::string(s_Prop.m_pType->typeInfo()->m_pTypeName).find_first_of('.') != std::string::npos && !s_Prop.m_pType->typeInfo()->isEnum())
				return;

			if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
			{
				if (s_Prop.m_pType->typeInfo()->m_pTypeName != std::string("TArray"))
				{
					auto s_ArrayType = reinterpret_cast<IArrayType*>(s_Prop.m_pType->typeInfo());

					if (ZString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName).StartsWith("TPair<") ||
						ZString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName).StartsWith("TMap<") ||
						ZString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName).StartsWith("TMultiMap<"))
					{
						auto s_Parts1 = SplitString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName, '<');
						auto s_Parts2 = SplitString(s_Parts1[1], ',');

						s_GenType->Dependencies.insert(s_Parts2[0]);
						s_GenType->Dependencies.insert(s_Parts2[1].substr(0, s_Parts2[1].size() - 1));
					}
					else if (ZString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName).StartsWith("TArray<") ||
						ZString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName).StartsWith("TFixedArray<"))
					{
						auto s_Parts = SplitString(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName, '<');
						s_GenType->Dependencies.insert(s_Parts[1].substr(0, s_Parts[1].size() - 1));
					}
					else
					{
						s_GenType->Dependencies.insert(s_ArrayType->m_pArrayElementType->typeInfo()->m_pTypeName);
					}
				}
			}
			else if (ZString(s_Prop.m_pType->typeInfo()->m_pTypeName).StartsWith("TPair<") ||
				ZString(s_Prop.m_pType->typeInfo()->m_pTypeName).StartsWith("TMap<") ||
				ZString(s_Prop.m_pType->typeInfo()->m_pTypeName).StartsWith("TMultiMap<"))
			{
				auto s_Parts1 = SplitString(s_Prop.m_pType->typeInfo()->m_pTypeName, '<');
				auto s_Parts2 = SplitString(s_Parts1[1], ',');

				s_GenType->Dependencies.insert(s_Parts2[0]);
				s_GenType->Dependencies.insert(s_Parts2[1].substr(0, s_Parts2[1].size() - 1));
			}
			else
			{
				s_GenType->Dependencies.insert(s_Prop.m_pType->typeInfo()->m_pTypeName);
			}

			std::string s_PropTypeName = s_Prop.m_pType->typeInfo()->m_pTypeName;

			s_HeaderStream << s_Indent << "\t" << NormalizeName(s_Prop.m_pType) << " " << s_Prop.m_pName << ";";
		}

		s_HeaderStream << " // 0x" << std::hex << std::uppercase << s_Prop.m_nOffset << std::dec << std::endl;
	}

	s_HeaderStream << s_Indent << "};" << std::endl;

	if (s_IsNamespaced)
	{
		s_HeaderStream << "}" << std::endl;
	}

	s_HeaderStream << std::endl;

	s_HeaderStream.flush();

	// Write to file.
	s_GenType->Header = s_HeaderStream.str();

	std::ostringstream s_SourceStream;

	s_SourceStream << "ZHMTypeInfo " << s_NormalizedName << "::TypeInfo = ZHMTypeInfo(\"" << s_TypeName << "\", sizeof(" << s_NormalizedName << "), alignof(" << s_NormalizedName << "), " << s_NormalizedName << "::WriteJson, " << s_NormalizedName << "::WriteSimpleJson, " << s_NormalizedName << "::FromSimpleJson, " << s_NormalizedName << "::Serialize);" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::WriteJson(void* p_Object, std::ostream& p_Stream)" << std::endl;
	s_SourceStream << "{" << std::endl;

	// TODO: Support for inherited classes.

	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "\tp_Stream << \"{\";" << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		// TODO: Add support for namespaced types.
		if (s_PropTypeName.find_first_of('.') != std::string::npos && !s_Prop.m_pType->typeInfo()->isEnum())
			return;

		s_SourceStream << "\tp_Stream << JsonStr(\"" << s_Prop.m_pName << "\") << \":\";" << std::endl;

		s_SourceStream << "\tp_Stream << \"{\" << JsonStr(\"$type\") << \":\" << JsonStr(\"" << s_PropTypeName << "\") << \",\" << JsonStr(\"$val\") << \":\";" << std::endl;

		if (s_Prop.m_pType->typeInfo()->isPrimitive())
		{
			if (s_PropTypeName == "uint8" || s_PropTypeName == "int8")
				s_SourceStream << "\tp_Stream << static_cast<int>(s_Object->" << s_Prop.m_pName << ");" << std::endl;
			else
				s_SourceStream << "\tp_Stream << s_Object->" << s_Prop.m_pName << ";" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\tp_Stream << \"{\" << JsonStr(\"$enumVal\") << \":\" << static_cast<int>(s_Object->" << s_Prop.m_pName << ") << \",\" << JsonStr(\"$enumValName\") << \":\" << JsonStr(ZHMEnums::GetEnumValueName(\"" << s_PropTypeName << "\", static_cast<int>(s_Object->" << s_Prop.m_pName << "))) << \"}\";" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			s_SourceStream << "\tp_Stream << JsonStr(s_Object->" << s_Prop.m_pName << ");" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
		{
			GenerateArrayJsonWriter(s_Prop.m_pType, s_SourceStream, "s_Object->" + std::string(s_Prop.m_pName));
		}
		else
		{
			s_SourceStream << "\t" << s_PropTypeName << "::WriteJson(&s_Object->" << s_Prop.m_pName << ", p_Stream);" << std::endl;
		}

		s_SourceStream << "\tp_Stream << \"}\";" << std::endl;

		if (i < s_Type->m_nPropertyCount - 1)
		{
			s_SourceStream << "\tp_Stream << \",\";" << std::endl;
		}

		s_SourceStream << std::endl;
	}

	s_SourceStream << "\tp_Stream << \"}\";" << std::endl;
	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::WriteSimpleJson(void* p_Object, std::ostream& p_Stream)" << std::endl;
	s_SourceStream << "{" << std::endl;

	// TODO: Support for inherited classes.

	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "\tp_Stream << \"{\";" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		// TODO: Add support for namespaced types.
		if (s_PropTypeName.find_first_of('.') != std::string::npos && !s_Prop.m_pType->typeInfo()->isEnum())
			return;

		s_SourceStream << "\tp_Stream << JsonStr(\"" << s_Prop.m_pName << "\") << \":\";" << std::endl;

		if (s_Prop.m_pType->typeInfo()->isPrimitive())
		{
			if (s_Prop.m_pName == std::string("nPropertyID"))
			{
				s_SourceStream << "\t{" << std::endl;
				s_SourceStream << "\t\tauto s_PropertyName = ZHMProperties::PropertyToString(s_Object->" << s_Prop.m_pName << ");" << std::endl;
				s_SourceStream << std::endl;
				s_SourceStream << "\t\tif (s_PropertyName.size() == 0)" << std::endl;
				s_SourceStream << "\t\t\tp_Stream << s_Object->" << s_Prop.m_pName << ";" << std::endl;
				s_SourceStream << "\t\telse" << std::endl;
				s_SourceStream << "\t\t\tp_Stream << JsonStr(s_PropertyName);" << std::endl;
				s_SourceStream << "\t}" << std::endl;
			}
			else
			{
				if (s_PropTypeName == "uint8" || s_PropTypeName == "int8")
					s_SourceStream << "\tp_Stream << static_cast<int>(s_Object->" << s_Prop.m_pName << ");" << std::endl;
				else
					s_SourceStream << "\tp_Stream << s_Object->" << s_Prop.m_pName << ";" << std::endl;
			}
		}
		else if (s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\tp_Stream << JsonStr(ZHMEnums::GetEnumValueName(\"" << s_PropTypeName << "\", static_cast<int>(s_Object->" << s_Prop.m_pName << ")));" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			s_SourceStream << "\tp_Stream << JsonStr(s_Object->" << s_Prop.m_pName << ");" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonWriter(s_Prop.m_pType, s_SourceStream, "s_Object->" + std::string(s_Prop.m_pName));
		}
		else
		{
			s_SourceStream << "\t" << s_PropTypeName << "::WriteSimpleJson(&s_Object->" << s_Prop.m_pName << ", p_Stream);" << std::endl;
		}

		if (i < s_Type->m_nPropertyCount - 1)
		{
			s_SourceStream << "\tp_Stream << \",\";" << std::endl;
		}

		s_SourceStream << std::endl;
	}

	s_SourceStream << "\tp_Stream << \"}\";" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::FromSimpleJson(simdjson::ondemand::value p_Document, void* p_Target)" << std::endl;
	s_SourceStream << "{" << std::endl;

	// TODO: Support for inherited classes.

	s_SourceStream << "\t" << s_NormalizedName << " s_Object;" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		// TODO: Add support for namespaced types.
		if (s_PropTypeName.find_first_of('.') != std::string::npos && !s_Prop.m_pType->typeInfo()->isEnum())
			return;

		if (s_Prop.m_pType->typeInfo()->isPrimitive())
		{
			if (s_Prop.m_pName == std::string("nPropertyID"))
			{
				s_SourceStream << "\tif (p_Document[\"" << s_Prop.m_pName << "\"].type() == simdjson::ondemand::json_type::string)" << std::endl;
				s_SourceStream << "\t\ts_Object." << s_Prop.m_pName << " = Hash::Crc32(std::string_view(p_Document[\"" << s_Prop.m_pName << "\"]));" << std::endl;
				s_SourceStream << "\telse" << std::endl;
				s_SourceStream << "\t\ts_Object." << s_Prop.m_pName << " = static_cast<uint32>(int64_t(p_Document[\"" << s_Prop.m_pName << "\"]));" << std::endl;
			}
			else
			{
				if (s_PropTypeName == "int8" || s_PropTypeName == "uint8" || s_PropTypeName == "int16" || s_PropTypeName == "uint16" || s_PropTypeName == "int32" || s_PropTypeName == "uint32")
					s_SourceStream << "\ts_Object." << s_Prop.m_pName << " = static_cast<" << s_PropTypeName << ">(int64_t(p_Document[\"" << s_Prop.m_pName << "\"]));" << std::endl;
				else if (s_PropTypeName == "float32")
					s_SourceStream << "\ts_Object." << s_Prop.m_pName << " = static_cast<" << s_PropTypeName << ">(double(p_Document[\"" << s_Prop.m_pName << "\"]));" << std::endl;
				else
					s_SourceStream << "\ts_Object." << s_Prop.m_pName << " = " << s_PropTypeName << "(p_Document[\"" << s_Prop.m_pName << "\"]);" << std::endl;
			}
		}
		else if (s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\ts_Object." << s_Prop.m_pName << " = static_cast<" << NormalizeName(s_Prop.m_pType) << ">(ZHMEnums::GetEnumValueByName(\"" << s_PropTypeName << "\", std::string_view(p_Document[\"" << s_Prop.m_pName << "\"])));" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->m_pTypeName == std::string("ZString"))
		{
			s_SourceStream << "\ts_Object." << s_Prop.m_pName << " = std::string_view(p_Document[\"" << s_Prop.m_pName << "\"]);" << std::endl;
		}
		else if (s_Prop.m_pType->typeInfo()->isArray() || s_Prop.m_pType->typeInfo()->isFixedArray())
		{
			GenerateArraySimpleJsonReader(s_Prop.m_pType, s_SourceStream, "s_Object." + std::string(s_Prop.m_pName), "p_Document[\"" + std::string(s_Prop.m_pName) + "\"]");
		}
		else
		{
			s_SourceStream << "\t{" << std::endl;
			s_SourceStream << "\t\t" << s_PropTypeName << " s_Item;" << std::endl;
			s_SourceStream << "\t\t" << s_PropTypeName << "::FromSimpleJson(p_Document[\"" << s_Prop.m_pName << "\"], &s_Item);" << std::endl;
			s_SourceStream << "\t\ts_Object." << s_Prop.m_pName << " = s_Item;" << std::endl;
			s_SourceStream << "\t}" << std::endl;
		}

		s_SourceStream << std::endl;
	}

	s_SourceStream << "\t*reinterpret_cast<" << s_NormalizedName << "*>(p_Target) = s_Object;" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream << "void " << s_NormalizedName << "::Serialize(void* p_Object, ZHMSerializer& p_Serializer, uintptr_t p_OwnOffset)" << std::endl;
	s_SourceStream << "{" << std::endl;
	s_SourceStream << "\tauto* s_Object = reinterpret_cast<" << s_NormalizedName << "*>(p_Object);" << std::endl;
	s_SourceStream << std::endl;

	for (uint16_t i = 0; i < s_Type->m_nPropertyCount; ++i)
	{
		auto s_Prop = s_Type->m_pProperties[i];
		auto s_PropTypeName = std::string(s_Prop.m_pType->typeInfo()->m_pTypeName);

		if (s_PropTypeName == std::string("TArray"))
			continue;

		// TODO: Add support for namespaced types.
		if (s_PropTypeName.find_first_of('.') != std::string::npos && !s_Prop.m_pType->typeInfo()->isEnum())
			return;

		if (!s_Prop.m_pType->typeInfo()->isPrimitive() && !s_Prop.m_pType->typeInfo()->isEnum())
		{
			s_SourceStream << "\t" << NormalizeName(s_Prop.m_pType) << "::Serialize(&s_Object->" << s_Prop.m_pName << ", p_Serializer, p_OwnOffset + offsetof(" << s_NormalizedName << ", " << s_Prop.m_pName << "));" << std::endl;
		}
	}

	if (s_TypeName == "ZRuntimeResourceID")
		s_SourceStream << "\t" << "p_Serializer.RegisterRuntimeResourceId(p_OwnOffset);" << std::endl;

	s_SourceStream << "}" << std::endl;
	s_SourceStream << std::endl;

	s_SourceStream.flush();

	// Write to file.
	s_GenType->Source = s_SourceStream.str();

	s_GenType->TypeName = s_TypeName;

	m_ReflectiveClasses[s_TypeName] = s_GenType;
}

void CodeGen::GenerateReflectiveEnum(STypeID* p_Type)
{
	auto s_Type = reinterpret_cast<IEnumType*>(p_Type->typeInfo());

	std::string s_EnumTypeName = s_Type->m_pTypeName;

	std::ostringstream s_Stream;

	s_Stream << "// 0x" << std::hex << std::uppercase << p_Type << " (Size: 0x" << std::hex << std::uppercase << s_Type->m_nTypeSize << ")" << std::dec << std::endl;
	s_Stream << "enum class " << NormalizeName(p_Type) << std::endl;
	s_Stream << "{" << std::endl;

	for (auto it = s_Type->m_entries.begin(); it != s_Type->m_entries.end(); ++it)
		s_Stream << "\t" << it->m_pName << " = " << std::dec << it->m_nValue << "," << std::endl;

	s_Stream << "};" << std::endl << std::endl;
	s_Stream.flush();

	// Write to file.
	auto s_GenType = new GeneratedType();
	s_GenType->TypeName = s_Type->m_pTypeName;
	s_GenType->Header = s_Stream.str();

	m_ReflectiveClasses[s_Type->m_pTypeName] = s_GenType;
}

bool IsPrimitive(const std::string& p_TypeName)
{
	return p_TypeName == "int8" ||
		p_TypeName == "uint8" ||
		p_TypeName == "int16" ||
		p_TypeName == "uint16" ||
		p_TypeName == "int32" ||
		p_TypeName == "uint32" ||
		p_TypeName == "int64" ||
		p_TypeName == "uint64" ||
		p_TypeName == "float32" ||
		p_TypeName == "float64" ||
		p_TypeName == "bool" ||
		p_TypeName == "ZVariant" ||
		p_TypeName == "TypeID" ||
		p_TypeName == "ZRepositoryID" ||
		p_TypeName == "ZString";
}

void CodeGen::Visit(GeneratedType* p_Type, std::unordered_set<GeneratedType*>& p_Visited, std::vector<GeneratedType*>& p_Sorted)
{
	if (p_Visited.find(p_Type) == p_Visited.end())
	{
		p_Visited.insert(p_Type);

		for (auto& s_Dependency : p_Type->Dependencies)
		{
			auto it = m_ReflectiveClasses.find(s_Dependency);

			if (it != m_ReflectiveClasses.end())
			{
				if (it->second->ShouldSkip)
				{
					p_Type->ShouldSkip = true;
				}
				else
				{
					p_Type->ShouldSkip = false;
					Visit(it->second, p_Visited, p_Sorted);
				}
			}
			else if (IsPrimitive(s_Dependency))
			{
				p_Type->ShouldSkip = false;
			}
			else
			{
				// Could not find a dependency for this type. Skip.
				printf("Could not find dependency '%s' for type '%s'. Skipping.\n", s_Dependency.c_str(), p_Type->TypeName.c_str());
				p_Type->ShouldSkip = true;
			}

			if (p_Type->ShouldSkip)
				break;
		}

		p_Sorted.push_back(p_Type);
	}
	else if (std::find(p_Sorted.begin(), p_Sorted.end(), p_Type) == p_Sorted.end())
	{
		printf("Circular dependency uwu.\n");
	}
}

void CodeGen::GenerateReflectiveClasses()
{
	// We need to do a topological sort so everything is defined in dependent order.
	std::vector<GeneratedType*> s_Sorted;
	std::unordered_set<GeneratedType*> s_Visited;

	for (auto& s_Item : m_ReflectiveClasses)
	{
		Visit(s_Item.second, s_Visited, s_Sorted);
	}

	for (auto& s_Type : s_Sorted)
	{
		for (auto& s_Dependency : s_Type->Dependencies)
		{
			auto it = m_ReflectiveClasses.find(s_Dependency);

			if (it != m_ReflectiveClasses.end() && it->second->ShouldSkip)
			{
				s_Type->ShouldSkip = true;
				break;
			}
		}

		if (s_Type->ShouldSkip)
			continue;

		m_ReflectiveClassesHeaderFile << s_Type->Header;
		m_ReflectiveClassesSourceFile << s_Type->Source;
	}
}

void CodeGen::GeneratePropertyNamesFiles()
{
	m_PropertyNamesHeaderFile << "/*" << std::endl;
	m_PropertyNamesHeaderFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_PropertyNamesHeaderFile << " *" << std::endl;
	m_PropertyNamesHeaderFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_PropertyNamesHeaderFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_PropertyNamesHeaderFile << " */" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "#pragma once" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "#include <cstdint>" << std::endl;
	m_PropertyNamesHeaderFile << "#include <unordered_map>" << std::endl;
	m_PropertyNamesHeaderFile << "#include <string>" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "struct ZHMPropertyName;" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "class ZHMProperties" << std::endl;
	m_PropertyNamesHeaderFile << "{" << std::endl;
	m_PropertyNamesHeaderFile << "public:" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic std::string PropertyToString(uint32_t p_PropertyId);" << std::endl;
	m_PropertyNamesHeaderFile << "\tstatic std::unordered_map<uint32_t, ZHMPropertyName*>* g_Properties;" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "private:" << std::endl;

	m_PropertyNamesSourceFile << "/*" << std::endl;
	m_PropertyNamesSourceFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_PropertyNamesSourceFile << " *" << std::endl;
	m_PropertyNamesSourceFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_PropertyNamesSourceFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_PropertyNamesSourceFile << " */" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "#include \"ZHMProperties.h\"" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "std::unordered_map<uint32_t, ZHMPropertyName*>* ZHMProperties::g_Properties = nullptr;" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "std::string ZHMProperties::PropertyToString(uint32_t p_PropertyId)" << std::endl;
	m_PropertyNamesSourceFile << "{" << std::endl;
	m_PropertyNamesSourceFile << "\tauto it = g_Properties->find(p_PropertyId);" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\tif (it == g_Properties->end())" << std::endl;
	m_PropertyNamesSourceFile << "\t\treturn \"\";" << std::endl;
	m_PropertyNamesSourceFile << std::endl;
	m_PropertyNamesSourceFile << "\treturn it->second->Name;" << std::endl;
	m_PropertyNamesSourceFile << "}" << std::endl;
	m_PropertyNamesSourceFile << std::endl;

	for (auto& s_Property : m_PropertyNames)
	{
		m_PropertyNamesHeaderFile << "\tstatic ZHMPropertyName g_Property_" << s_Property.second << ";" << std::endl;
		m_PropertyNamesSourceFile << "ZHMPropertyName ZHMProperties::g_Property_" << s_Property.second << " = ZHMPropertyName(\"" << s_Property.second << "\", " << s_Property.first << ");" << std::endl;
	}


	m_PropertyNamesHeaderFile << "};" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "struct ZHMPropertyName" << std::endl;
	m_PropertyNamesHeaderFile << "{" << std::endl;
	m_PropertyNamesHeaderFile << "\tZHMPropertyName(const char* p_Name, uint32_t p_Id) : Name(p_Name), Id(p_Id)" << std::endl;
	m_PropertyNamesHeaderFile << "\t{" << std::endl;
	m_PropertyNamesHeaderFile << "\t\tif (ZHMProperties::g_Properties == nullptr)" << std::endl;
	m_PropertyNamesHeaderFile << "\t\t\tZHMProperties::g_Properties = new std::unordered_map<uint32_t, ZHMPropertyName*>();" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "\t\t(*ZHMProperties::g_Properties)[p_Id] = this;" << std::endl;
	m_PropertyNamesHeaderFile << "\t}" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
	m_PropertyNamesHeaderFile << "\tstd::string Name;" << std::endl;
	m_PropertyNamesHeaderFile << "\tuint32_t Id;" << std::endl;
	m_PropertyNamesHeaderFile << "};" << std::endl;
	m_PropertyNamesHeaderFile << std::endl;
}

void CodeGen::GenerateEnumsFiles()
{
	m_EnumsHeaderFile << "/*" << std::endl;
	m_EnumsHeaderFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_EnumsHeaderFile << " *" << std::endl;
	m_EnumsHeaderFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_EnumsHeaderFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_EnumsHeaderFile << " */" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "#pragma once" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "#include <cstdint>" << std::endl;
	m_EnumsHeaderFile << "#include <unordered_map>" << std::endl;
	m_EnumsHeaderFile << "#include <string>" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "class ZHMEnums" << std::endl;
	m_EnumsHeaderFile << "{" << std::endl;
	m_EnumsHeaderFile << "private:" << std::endl;
	m_EnumsHeaderFile << "\tstruct EnumRegistrar { EnumRegistrar() { RegisterEnums(); } };" << std::endl;
	m_EnumsHeaderFile << "\tstatic std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>* g_Enums;" << std::endl;
	m_EnumsHeaderFile << "\tstatic EnumRegistrar g_Registrar;" << std::endl;
	m_EnumsHeaderFile << "\tstatic void RegisterEnums();" << std::endl;
	m_EnumsHeaderFile << std::endl;
	m_EnumsHeaderFile << "public:" << std::endl;
	m_EnumsHeaderFile << "\tstatic std::string GetEnumValueName(const std::string& p_TypeName, int32_t p_Value);" << std::endl;
	m_EnumsHeaderFile << "\tstatic int32_t GetEnumValueByName(const std::string& p_TypeName, std::string_view p_Name);" << std::endl;
	m_EnumsHeaderFile << "\tstatic bool IsTypeNameEnum(const std::string& p_TypeName);" << std::endl;
	m_EnumsHeaderFile << "};" << std::endl;

	m_EnumsSourceFile << "/*" << std::endl;
	m_EnumsSourceFile << " * WARNING: This file is automatically generated. DO NOT MODIFY unless you know what you're doing." << std::endl;
	m_EnumsSourceFile << " *" << std::endl;
	m_EnumsSourceFile << " * If you wish to regenerate this file because of a game update use the ZHM Mod SDK CodeGen mod:" << std::endl;
	m_EnumsSourceFile << " * https://github.com/OrfeasZ/ZHMModSDK" << std::endl;
	m_EnumsSourceFile << " */" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "#include \"ZHMEnums.h\"" << std::endl;
	m_EnumsSourceFile << "#include <ZHM/ZHMTypeInfo.h>" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>* ZHMEnums::g_Enums = nullptr;" << std::endl;
	m_EnumsSourceFile << "ZHMEnums::EnumRegistrar ZHMEnums::g_Registrar;" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "std::string ZHMEnums::GetEnumValueName(const std::string& p_TypeName, int32_t p_Value)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tauto s_EnumIt = g_Enums->find(p_TypeName);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_EnumIt == g_Enums->end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn \"\";" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tauto s_ValueIt = s_EnumIt->second.find(p_Value);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_ValueIt == s_EnumIt->second.end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn \"\";" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\treturn s_ValueIt->second;" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "int32_t ZHMEnums::GetEnumValueByName(const std::string& p_TypeName, std::string_view p_Name)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tauto s_EnumIt = g_Enums->find(p_TypeName);" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tif (s_EnumIt == g_Enums->end())" << std::endl;
	m_EnumsSourceFile << "\t\treturn 0;" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\tfor (auto s_Pair : s_EnumIt->second)" << std::endl;
	m_EnumsSourceFile << "\t\tif (s_Pair.second == p_Name)" << std::endl;
	m_EnumsSourceFile << "\t\t\treturn s_Pair.first;" << std::endl;
	m_EnumsSourceFile << std::endl;
	m_EnumsSourceFile << "\treturn 0;" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "bool ZHMEnums::IsTypeNameEnum(const std::string& p_TypeName)" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\treturn g_Enums->find(p_TypeName) != g_Enums->end();" << std::endl;
	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;

	m_EnumsSourceFile << "void ZHMEnums::RegisterEnums()" << std::endl;
	m_EnumsSourceFile << "{" << std::endl;
	m_EnumsSourceFile << "\tg_Enums = new std::unordered_map<std::string, std::unordered_map<int32_t, std::string>>();" << std::endl;
	m_EnumsSourceFile << std::endl;

	for (auto& s_Enum : m_Enums)
	{
		m_EnumsSourceFile << "\t(*g_Enums)[\"" << s_Enum.first << "\"] = {" << std::endl;

		for (auto& s_Value : s_Enum.second)
		{
			m_EnumsSourceFile << "\t\t{ " << std::to_string(s_Value.first) << ", \"" << s_Value.second << "\" }," << std::endl;
		}

		m_EnumsSourceFile << "\t};" << std::endl;
		m_EnumsSourceFile << std::endl;
	}

	m_EnumsSourceFile << "}" << std::endl;
	m_EnumsSourceFile << std::endl;
}


DECLARE_ZHM_PLUGIN(CodeGen);
